#!/usr/bin/env python

"""
Usage:
    market stock <code>
    market new <code>
    market scan <filename>
    market review <watch> <positions>
    market chain <code> [<expiry>
        [--strike=<strike>] [--offset=<offset>] [--type=<type>]]
    market portfolio

Options:
    -s <strike> --strike==<strike>  # specific strike
    -o <offset> --offset==<offset>  # offset
    -t <type> --type==<type>  # option type: c or p
"""


__version__ = '0.0.1'


from datetime import datetime

import sys

from dateutil.parser import parse

from docopt import docopt

from market import portfolio
from market import api


def intword(n):
    n = n / (1000000.0)
    if n > 1000:
        l = 'b'
        n = n / 1000
    else:
        l = 'm'
    ret = '%7.2f' % n
    return ret + l


def perc(f):
    ret = '%7.2f%%' % f
    return ret


def do_stock(code):
    nasdaq = api.Nasdaq()
    data = nasdaq.summary(code)

    estimate = api.Estimize().estimate(code)
    income = nasdaq.income_statement_annual(code)

    if estimate:
        trailing_eps = sum(
            estimate[x].earnings.actual for x in estimate.keys()[-5:-1])
        trailing_earnings = trailing_eps * data['outstanding']
        trailing_revenue = sum(
            estimate[x].revenue.actual for x in estimate.keys()[-5:-1]
            ) * 1000000

        future_eps = sum(
            estimate[x].earnings.actual for x in estimate.keys()[-4:-1]
            ) + estimate[estimate.keys()[-1]].earnings.wallst
        future_earnings = future_eps * data['outstanding']
        future_revenue = (sum(
            estimate[x].revenue.actual for x in estimate.keys()[-4:-1]
            ) + estimate[estimate.keys()[-1]].revenue.wallst) * 1000000

    print '%s %s' % (code.upper(), data['quote'])
    print
    print '    Market cap:', intword(data['market_cap'])
    print '    Yield:     ', perc(data['current_yield'])
    print '    Industry:  ', data['industry']

    income = nasdaq.income_statement_annual(code)
    if estimate:
        print
        print '    Income: Reports', estimate.to_report.strftime('%b %d'), \
            '-', (estimate.to_report - datetime.now()).days, 'days'

    """
    def fmt_eps(name, revenue, eps):
        name = str(name)
        print '\t', \
            name, \
            ' '*(8-len(name)), \
            intword(revenue), \
            '   ', \
            '%7.2f' % eps, \
            '  ', \
            '%5.2f' % (data['quote'] / eps), \
            '  ', \
            '%5.2f' % (data['market_cap'] / float(revenue))
    fmt_eps('future', future_revenue, future_eps)
    fmt_eps('trailing', trailing_revenue, trailing_eps)
    print
    """

    def fmt(name, revenue, earnings):
        name = str(name)
        print '\t', \
            name, \
            ' '*(8-len(name)), \
            intword(revenue), \
            '  ', \
            intword(earnings), \
            '  ', \
            '%5.2f' % (data['market_cap'] / earnings), \
            '  ', \
            '%5.2f' % (data['market_cap'] / float(revenue))

    if estimate:
        fmt('future', future_revenue, future_earnings)
        fmt('trailing', trailing_revenue, trailing_earnings)
    for period in income:
        fmt(period.year, income[period]['sales'], income[period]['earnings'])

    print
    print '    Balance sheet:'
    sheet = nasdaq.balance_sheet_annual(code)
    for period in sheet:
        print '\t', \
            period.year, \
            '  ', \
            intword(sheet[period]['total_assets']), \
            '  ', \
            intword(sheet[period]['total_liabilities']), \
            '  ', \
            intword(sheet[period]['total_equity']), \
            '  ', \
            '%.2f' % (
                data['market_cap'] / float(sheet[period]['total_equity']))


def do_new(code):
    nasdaq = api.Nasdaq()
    data = nasdaq.summary(code)
    income = nasdaq.income_statement_quarterly(code)
    total = sum([x['earnings'] for x in income.values()])
    print intword(total)


def do_scan(filename):
    nasdaq = api.Nasdaq()
    lines = open(filename).readlines()
    codes = [x.strip() for x in lines if x.strip()]

    for code in codes:
        summary = nasdaq.summary(code)
        estimate = api.Estimize().estimate(code)
        print '%-6s %s %s' % (
            code,
            summary['quote'],
            estimate.to_report.strftime('%b %d'))
        chain = api.Google().option_chain(code)
        for expiry in chain:
            if expiry.togo > 30 and expiry.togo < 60:
                strike = expiry.p.near(summary['quote']*.95, 1)[1]
                print expiry.togo, strike.mid, strike.strike, strike.ratio, strike.ratio_annual


def do_review(watch, positions):
    # import fabulous
    # print help(fabulous)

    sixtohex = [0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff, ]

    def ntorgb(n):
        n -= 16
        b = n % 6
        g = (n / 6) % 6
        r = (n / 6 / 6) % 6
        return [sixtohex[x] for x in (r, g, b)]

    def rgbton(rgb):
        r, g, b = [sixtohex.index(code) for code in rgb]
        n = b + (6 * g) + (6 * 6 * r) + 16
        return n

    def rgbdistance(rgb1, rgb2):
        return sum(abs(rgb1[i] - rgb2[i]) for i in xrange(3))

    def rgbmix(rgbs):
        import copy
        rgbs = copy.copy(rgbs)
        mix = []
        while rgbs:
            mix.append(rgbs.pop())
            rgbs.sort(key=lambda item: sum(rgbdistance(x, item) for x in mix))
        return mix

    rng = []

    for i in range(16, 232):
        keep = True
        rgb = ntorgb(i)
        if rgbdistance(rgb, [60, 60, 60]) > 200:
            for check in rng:
                if rgbdistance(rgb, check) < 180:
                    keep = False
                    break
            if keep:
                rng.append(rgb)

    rng = rgbmix(rng)
    rng = [rgbton(x) for x in rng]

    from fabulous.color import fg256

    rng.reverse()
    print rng
    print ''.join(str(fg256(i, 'A')) for i in rng)

    assigned = {}


    nasdaq = api.Nasdaq()

    lines = open(watch).readlines()
    codes = set([x.strip().upper() for x in lines if x.strip()])

    class Position(object):
        def __init__(self, code, expiry, strike, typ, n):
            self.code = code
            self.expiry = expiry
            self.strike = strike
            self.typ = typ
            self.n = n

        @property
        def contract(self):
            chain = api.Google().option_chain(self.code)
            contract = chain[self.expiry.strftime('%Y-%m-%d')][self.typ][self.strike]
            return contract

        def pprint(self):
            print '%-4s %s  %-6s %6.2f   options  %s %4s %6.2f %6.2f %6.2f' % (
                (self.expiry - datetime.now()).days,
                self.expiry.strftime('%b %d'),
                fg256(assigned[self.code], self.code),
                nasdaq.summary(self.code)['quote'],
                self.typ,
                self.n,
                self.strike,
                self.contract.bid,
                self.contract.ask,
                )


    class Watch(object):
        def __init__(self, code, expiry, summary):
            self.code = code
            self.expiry = expiry
            self.summary = summary

        def pprint(self):
            delta = self.summary['quote'] - self.summary['previous_close']
            if delta >= 0:
                direction = u'\u25B2'
            else:
                direction = u'\u25BC'
                delta = abs(delta)

            print '%-4s %s  %-6s %6.2f   reports  %s %6.2f' % (
                (self.expiry - datetime.now()).days,
                self.expiry.strftime('%b %d'),
                fg256(assigned[self.code], self.code),
                self.summary['quote'],
                direction,
                delta,
                )

    out = []

    lines = open(positions).readlines()
    for line in lines:
        if line.startswith('#'):
            continue
        bits = line.strip().split()
        if len(bits) != 5:
            continue
        code, expiry, strike, typ, n = bits
        expiry = parse(expiry)
        strike = float(strike)
        n = int(n)
        out.append(Position(code, expiry, strike, typ, n))
        codes.add(code)

    codes = list(codes)
    for i in range(len(codes)):
        assigned[codes[i]] = rng[i]

    for code in codes:
        summary = nasdaq.summary(code)
        estimate = api.Estimize().estimate(code)
        out.append(Watch(code, estimate.to_report, summary))

    for foo in sorted(out, lambda x, y: cmp(x.expiry, y.expiry)):
        foo.pprint()


def do_portfolio():
    p = portfolio.Portfolio()
    for spread in p.spreads:
        print spread


def do_chain(code, expiry=None, strike=None, offset=None, typ=None):
    nasdaq = api.Nasdaq()
    data = nasdaq.summary(code)
    print '%s %s' % (code.upper(), data['quote'])

    chain = api.Google().option_chain(code)
    if not expiry:
        for expiry in chain:
            print expiry
        return

    price = data['quote']
    if offset:
        price = price + (price*(float(offset)/100))

    if strike:
        strike = float(strike)

    typs = typ and [typ.upper()] or ['C', 'P']

    if '+' in expiry:
        expiry, n = expiry.split('+')
        n = int(n)+1
    else:
        n = 1
    expiry = chain[expiry]

    while True:
        for typ in typs:
            if strike:
                print expiry.togo, expiry[typ].at(strike)
            else:
                print expiry.togo
                for x in expiry[typ].near(price, 3):
                    print '%02.2f' % (((x.ask+x.bid)/2)/expiry.togo), x
        n -= 1
        if not n:
            break
        expiry = expiry.next()


def main(argv):
    if argv.get('stock'):
        return do_stock(argv['<code>'])

    if argv.get('new'):
        return do_new(argv['<code>'])

    if argv.get('scan'):
        return do_scan(argv['<filename>'])

    if argv.get('review'):
        return do_review(argv['<watch>'], argv['<positions>'])

    if argv.get('chain'):
        return do_chain(
            argv['<code>'],
            expiry=argv.get('<expiry>'),
            strike=argv.get('--strike'),
            offset=argv.get('--offset'),
            typ=argv.get('--type'))

    if argv.get('portfolio'):
        return do_portfolio()


if __name__ == '__main__':
    argv = docopt(__doc__, version=__version__)
    sys.exit(main(argv))
